// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: distributor.proto

#ifndef PROTOBUF_distributor_2eproto__INCLUDED
#define PROTOBUF_distributor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ddc {
namespace distributor {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_distributor_2eproto();
void protobuf_AssignDesc_distributor_2eproto();
void protobuf_ShutdownFile_distributor_2eproto();

class Registration;
class FetchSplitRequest;
class FetchSplitResponse;
class HeartBeatRequest;
class HeartBeatResponse;
class ShutdownRequest;
class AnyRequest;

enum AnyRequest_Type {
  AnyRequest_Type_REGISTRATION = 1,
  AnyRequest_Type_FETCH_SPLIT_REQUEST = 2,
  AnyRequest_Type_FETCH_SPLIT_RESPONSE = 3,
  AnyRequest_Type_HEARTBEAT_REQUEST = 4,
  AnyRequest_Type_HEARTBEAT_RESPONSE = 5,
  AnyRequest_Type_SHUTDOWN_REQUEST = 6
};
bool AnyRequest_Type_IsValid(int value);
const AnyRequest_Type AnyRequest_Type_Type_MIN = AnyRequest_Type_REGISTRATION;
const AnyRequest_Type AnyRequest_Type_Type_MAX = AnyRequest_Type_SHUTDOWN_REQUEST;
const int AnyRequest_Type_Type_ARRAYSIZE = AnyRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnyRequest_Type_descriptor();
inline const ::std::string& AnyRequest_Type_Name(AnyRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnyRequest_Type_descriptor(), value);
}
inline bool AnyRequest_Type_Parse(
    const ::std::string& name, AnyRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnyRequest_Type>(
    AnyRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Registration : public ::google::protobuf::Message {
 public:
  Registration();
  virtual ~Registration();

  Registration(const Registration& from);

  inline Registration& operator=(const Registration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Registration& default_instance();

  void Swap(Registration* other);

  // implements Message ----------------------------------------------

  Registration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Registration& from);
  void MergeFrom(const Registration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string ipAddress = 2;
  inline int ipaddress_size() const;
  inline void clear_ipaddress();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ipaddress(int index) const;
  inline ::std::string* mutable_ipaddress(int index);
  inline void set_ipaddress(int index, const ::std::string& value);
  inline void set_ipaddress(int index, const char* value);
  inline void set_ipaddress(int index, const char* value, size_t size);
  inline ::std::string* add_ipaddress();
  inline void add_ipaddress(const ::std::string& value);
  inline void add_ipaddress(const char* value);
  inline void add_ipaddress(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipaddress() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipaddress();

  // @@protoc_insertion_point(class_scope:ddc.distributor.Registration)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipaddress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static Registration* default_instance_;
};
// -------------------------------------------------------------------

class FetchSplitRequest : public ::google::protobuf::Message {
 public:
  FetchSplitRequest();
  virtual ~FetchSplitRequest();

  FetchSplitRequest(const FetchSplitRequest& from);

  inline FetchSplitRequest& operator=(const FetchSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchSplitRequest& default_instance();

  void Swap(FetchSplitRequest* other);

  // implements Message ----------------------------------------------

  FetchSplitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchSplitRequest& from);
  void MergeFrom(const FetchSplitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:ddc.distributor.FetchSplitRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static FetchSplitRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchSplitResponse : public ::google::protobuf::Message {
 public:
  FetchSplitResponse();
  virtual ~FetchSplitResponse();

  FetchSplitResponse(const FetchSplitResponse& from);

  inline FetchSplitResponse& operator=(const FetchSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchSplitResponse& default_instance();

  void Swap(FetchSplitResponse* other);

  // implements Message ----------------------------------------------

  FetchSplitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchSplitResponse& from);
  void MergeFrom(const FetchSplitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ddc.distributor.FetchSplitResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static FetchSplitResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatRequest : public ::google::protobuf::Message {
 public:
  HeartBeatRequest();
  virtual ~HeartBeatRequest();

  HeartBeatRequest(const HeartBeatRequest& from);

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRequest& default_instance();

  void Swap(HeartBeatRequest* other);

  // implements Message ----------------------------------------------

  HeartBeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatRequest& from);
  void MergeFrom(const HeartBeatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.HeartBeatRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatResponse : public ::google::protobuf::Message {
 public:
  HeartBeatResponse();
  virtual ~HeartBeatResponse();

  HeartBeatResponse(const HeartBeatResponse& from);

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatResponse& default_instance();

  void Swap(HeartBeatResponse* other);

  // implements Message ----------------------------------------------

  HeartBeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatResponse& from);
  void MergeFrom(const HeartBeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.HeartBeatResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static HeartBeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownRequest : public ::google::protobuf::Message {
 public:
  ShutdownRequest();
  virtual ~ShutdownRequest();

  ShutdownRequest(const ShutdownRequest& from);

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownRequest& default_instance();

  void Swap(ShutdownRequest* other);

  // implements Message ----------------------------------------------

  ShutdownRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownRequest& from);
  void MergeFrom(const ShutdownRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ddc.distributor.ShutdownRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static ShutdownRequest* default_instance_;
};
// -------------------------------------------------------------------

class AnyRequest : public ::google::protobuf::Message {
 public:
  AnyRequest();
  virtual ~AnyRequest();

  AnyRequest(const AnyRequest& from);

  inline AnyRequest& operator=(const AnyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnyRequest& default_instance();

  void Swap(AnyRequest* other);

  // implements Message ----------------------------------------------

  AnyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnyRequest& from);
  void MergeFrom(const AnyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AnyRequest_Type Type;
  static const Type REGISTRATION = AnyRequest_Type_REGISTRATION;
  static const Type FETCH_SPLIT_REQUEST = AnyRequest_Type_FETCH_SPLIT_REQUEST;
  static const Type FETCH_SPLIT_RESPONSE = AnyRequest_Type_FETCH_SPLIT_RESPONSE;
  static const Type HEARTBEAT_REQUEST = AnyRequest_Type_HEARTBEAT_REQUEST;
  static const Type HEARTBEAT_RESPONSE = AnyRequest_Type_HEARTBEAT_RESPONSE;
  static const Type SHUTDOWN_REQUEST = AnyRequest_Type_SHUTDOWN_REQUEST;
  static inline bool Type_IsValid(int value) {
    return AnyRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AnyRequest_Type_Type_MIN;
  static const Type Type_MAX =
    AnyRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AnyRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AnyRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AnyRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AnyRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ddc.distributor.AnyRequest.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ddc::distributor::AnyRequest_Type type() const;
  inline void set_type(::ddc::distributor::AnyRequest_Type value);

  // optional .ddc.distributor.Registration registration = 2;
  inline bool has_registration() const;
  inline void clear_registration();
  static const int kRegistrationFieldNumber = 2;
  inline const ::ddc::distributor::Registration& registration() const;
  inline ::ddc::distributor::Registration* mutable_registration();
  inline ::ddc::distributor::Registration* release_registration();
  inline void set_allocated_registration(::ddc::distributor::Registration* registration);

  // optional .ddc.distributor.FetchSplitRequest fetchSplitRequest = 3;
  inline bool has_fetchsplitrequest() const;
  inline void clear_fetchsplitrequest();
  static const int kFetchSplitRequestFieldNumber = 3;
  inline const ::ddc::distributor::FetchSplitRequest& fetchsplitrequest() const;
  inline ::ddc::distributor::FetchSplitRequest* mutable_fetchsplitrequest();
  inline ::ddc::distributor::FetchSplitRequest* release_fetchsplitrequest();
  inline void set_allocated_fetchsplitrequest(::ddc::distributor::FetchSplitRequest* fetchsplitrequest);

  // optional .ddc.distributor.FetchSplitResponse fetchSplitResponse = 4;
  inline bool has_fetchsplitresponse() const;
  inline void clear_fetchsplitresponse();
  static const int kFetchSplitResponseFieldNumber = 4;
  inline const ::ddc::distributor::FetchSplitResponse& fetchsplitresponse() const;
  inline ::ddc::distributor::FetchSplitResponse* mutable_fetchsplitresponse();
  inline ::ddc::distributor::FetchSplitResponse* release_fetchsplitresponse();
  inline void set_allocated_fetchsplitresponse(::ddc::distributor::FetchSplitResponse* fetchsplitresponse);

  // optional .ddc.distributor.HeartBeatRequest heartBeatRequest = 5;
  inline bool has_heartbeatrequest() const;
  inline void clear_heartbeatrequest();
  static const int kHeartBeatRequestFieldNumber = 5;
  inline const ::ddc::distributor::HeartBeatRequest& heartbeatrequest() const;
  inline ::ddc::distributor::HeartBeatRequest* mutable_heartbeatrequest();
  inline ::ddc::distributor::HeartBeatRequest* release_heartbeatrequest();
  inline void set_allocated_heartbeatrequest(::ddc::distributor::HeartBeatRequest* heartbeatrequest);

  // optional .ddc.distributor.HeartBeatResponse heartBeatResponse = 6;
  inline bool has_heartbeatresponse() const;
  inline void clear_heartbeatresponse();
  static const int kHeartBeatResponseFieldNumber = 6;
  inline const ::ddc::distributor::HeartBeatResponse& heartbeatresponse() const;
  inline ::ddc::distributor::HeartBeatResponse* mutable_heartbeatresponse();
  inline ::ddc::distributor::HeartBeatResponse* release_heartbeatresponse();
  inline void set_allocated_heartbeatresponse(::ddc::distributor::HeartBeatResponse* heartbeatresponse);

  // optional .ddc.distributor.ShutdownRequest shutdownRequest = 7;
  inline bool has_shutdownrequest() const;
  inline void clear_shutdownrequest();
  static const int kShutdownRequestFieldNumber = 7;
  inline const ::ddc::distributor::ShutdownRequest& shutdownrequest() const;
  inline ::ddc::distributor::ShutdownRequest* mutable_shutdownrequest();
  inline ::ddc::distributor::ShutdownRequest* release_shutdownrequest();
  inline void set_allocated_shutdownrequest(::ddc::distributor::ShutdownRequest* shutdownrequest);

  // @@protoc_insertion_point(class_scope:ddc.distributor.AnyRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_registration();
  inline void clear_has_registration();
  inline void set_has_fetchsplitrequest();
  inline void clear_has_fetchsplitrequest();
  inline void set_has_fetchsplitresponse();
  inline void clear_has_fetchsplitresponse();
  inline void set_has_heartbeatrequest();
  inline void clear_has_heartbeatrequest();
  inline void set_has_heartbeatresponse();
  inline void clear_has_heartbeatresponse();
  inline void set_has_shutdownrequest();
  inline void clear_has_shutdownrequest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ddc::distributor::Registration* registration_;
  ::ddc::distributor::FetchSplitRequest* fetchsplitrequest_;
  ::ddc::distributor::FetchSplitResponse* fetchsplitresponse_;
  ::ddc::distributor::HeartBeatRequest* heartbeatrequest_;
  ::ddc::distributor::HeartBeatResponse* heartbeatresponse_;
  ::ddc::distributor::ShutdownRequest* shutdownrequest_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_distributor_2eproto();
  friend void protobuf_AssignDesc_distributor_2eproto();
  friend void protobuf_ShutdownFile_distributor_2eproto();

  void InitAsDefaultInstance();
  static AnyRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// Registration

// required string id = 1;
inline bool Registration::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Registration::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Registration::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Registration::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Registration::id() const {
  return *id_;
}
inline void Registration::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Registration::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Registration::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Registration::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Registration::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Registration::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string ipAddress = 2;
inline int Registration::ipaddress_size() const {
  return ipaddress_.size();
}
inline void Registration::clear_ipaddress() {
  ipaddress_.Clear();
}
inline const ::std::string& Registration::ipaddress(int index) const {
  return ipaddress_.Get(index);
}
inline ::std::string* Registration::mutable_ipaddress(int index) {
  return ipaddress_.Mutable(index);
}
inline void Registration::set_ipaddress(int index, const ::std::string& value) {
  ipaddress_.Mutable(index)->assign(value);
}
inline void Registration::set_ipaddress(int index, const char* value) {
  ipaddress_.Mutable(index)->assign(value);
}
inline void Registration::set_ipaddress(int index, const char* value, size_t size) {
  ipaddress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Registration::add_ipaddress() {
  return ipaddress_.Add();
}
inline void Registration::add_ipaddress(const ::std::string& value) {
  ipaddress_.Add()->assign(value);
}
inline void Registration::add_ipaddress(const char* value) {
  ipaddress_.Add()->assign(value);
}
inline void Registration::add_ipaddress(const char* value, size_t size) {
  ipaddress_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Registration::ipaddress() const {
  return ipaddress_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Registration::mutable_ipaddress() {
  return &ipaddress_;
}

// -------------------------------------------------------------------

// FetchSplitRequest

// required string filename = 1;
inline bool FetchSplitRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchSplitRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchSplitRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchSplitRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FetchSplitRequest::filename() const {
  return *filename_;
}
inline void FetchSplitRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FetchSplitRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FetchSplitRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FetchSplitRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FetchSplitRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FetchSplitRequest::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FetchSplitResponse

// required string filename = 1;
inline bool FetchSplitResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchSplitResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchSplitResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchSplitResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FetchSplitResponse::filename() const {
  return *filename_;
}
inline void FetchSplitResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FetchSplitResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FetchSplitResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FetchSplitResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FetchSplitResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FetchSplitResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 2;
inline bool FetchSplitResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchSplitResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchSplitResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchSplitResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 FetchSplitResponse::status() const {
  return status_;
}
inline void FetchSplitResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// HeartBeatRequest

// -------------------------------------------------------------------

// HeartBeatResponse

// -------------------------------------------------------------------

// ShutdownRequest

// -------------------------------------------------------------------

// AnyRequest

// required .ddc.distributor.AnyRequest.Type type = 1;
inline bool AnyRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnyRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnyRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnyRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ddc::distributor::AnyRequest_Type AnyRequest::type() const {
  return static_cast< ::ddc::distributor::AnyRequest_Type >(type_);
}
inline void AnyRequest::set_type(::ddc::distributor::AnyRequest_Type value) {
  assert(::ddc::distributor::AnyRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .ddc.distributor.Registration registration = 2;
inline bool AnyRequest::has_registration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnyRequest::set_has_registration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnyRequest::clear_has_registration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnyRequest::clear_registration() {
  if (registration_ != NULL) registration_->::ddc::distributor::Registration::Clear();
  clear_has_registration();
}
inline const ::ddc::distributor::Registration& AnyRequest::registration() const {
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
inline ::ddc::distributor::Registration* AnyRequest::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) registration_ = new ::ddc::distributor::Registration;
  return registration_;
}
inline ::ddc::distributor::Registration* AnyRequest::release_registration() {
  clear_has_registration();
  ::ddc::distributor::Registration* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_registration(::ddc::distributor::Registration* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
}

// optional .ddc.distributor.FetchSplitRequest fetchSplitRequest = 3;
inline bool AnyRequest::has_fetchsplitrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnyRequest::set_has_fetchsplitrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnyRequest::clear_has_fetchsplitrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnyRequest::clear_fetchsplitrequest() {
  if (fetchsplitrequest_ != NULL) fetchsplitrequest_->::ddc::distributor::FetchSplitRequest::Clear();
  clear_has_fetchsplitrequest();
}
inline const ::ddc::distributor::FetchSplitRequest& AnyRequest::fetchsplitrequest() const {
  return fetchsplitrequest_ != NULL ? *fetchsplitrequest_ : *default_instance_->fetchsplitrequest_;
}
inline ::ddc::distributor::FetchSplitRequest* AnyRequest::mutable_fetchsplitrequest() {
  set_has_fetchsplitrequest();
  if (fetchsplitrequest_ == NULL) fetchsplitrequest_ = new ::ddc::distributor::FetchSplitRequest;
  return fetchsplitrequest_;
}
inline ::ddc::distributor::FetchSplitRequest* AnyRequest::release_fetchsplitrequest() {
  clear_has_fetchsplitrequest();
  ::ddc::distributor::FetchSplitRequest* temp = fetchsplitrequest_;
  fetchsplitrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_fetchsplitrequest(::ddc::distributor::FetchSplitRequest* fetchsplitrequest) {
  delete fetchsplitrequest_;
  fetchsplitrequest_ = fetchsplitrequest;
  if (fetchsplitrequest) {
    set_has_fetchsplitrequest();
  } else {
    clear_has_fetchsplitrequest();
  }
}

// optional .ddc.distributor.FetchSplitResponse fetchSplitResponse = 4;
inline bool AnyRequest::has_fetchsplitresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnyRequest::set_has_fetchsplitresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnyRequest::clear_has_fetchsplitresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnyRequest::clear_fetchsplitresponse() {
  if (fetchsplitresponse_ != NULL) fetchsplitresponse_->::ddc::distributor::FetchSplitResponse::Clear();
  clear_has_fetchsplitresponse();
}
inline const ::ddc::distributor::FetchSplitResponse& AnyRequest::fetchsplitresponse() const {
  return fetchsplitresponse_ != NULL ? *fetchsplitresponse_ : *default_instance_->fetchsplitresponse_;
}
inline ::ddc::distributor::FetchSplitResponse* AnyRequest::mutable_fetchsplitresponse() {
  set_has_fetchsplitresponse();
  if (fetchsplitresponse_ == NULL) fetchsplitresponse_ = new ::ddc::distributor::FetchSplitResponse;
  return fetchsplitresponse_;
}
inline ::ddc::distributor::FetchSplitResponse* AnyRequest::release_fetchsplitresponse() {
  clear_has_fetchsplitresponse();
  ::ddc::distributor::FetchSplitResponse* temp = fetchsplitresponse_;
  fetchsplitresponse_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_fetchsplitresponse(::ddc::distributor::FetchSplitResponse* fetchsplitresponse) {
  delete fetchsplitresponse_;
  fetchsplitresponse_ = fetchsplitresponse;
  if (fetchsplitresponse) {
    set_has_fetchsplitresponse();
  } else {
    clear_has_fetchsplitresponse();
  }
}

// optional .ddc.distributor.HeartBeatRequest heartBeatRequest = 5;
inline bool AnyRequest::has_heartbeatrequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnyRequest::set_has_heartbeatrequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnyRequest::clear_has_heartbeatrequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnyRequest::clear_heartbeatrequest() {
  if (heartbeatrequest_ != NULL) heartbeatrequest_->::ddc::distributor::HeartBeatRequest::Clear();
  clear_has_heartbeatrequest();
}
inline const ::ddc::distributor::HeartBeatRequest& AnyRequest::heartbeatrequest() const {
  return heartbeatrequest_ != NULL ? *heartbeatrequest_ : *default_instance_->heartbeatrequest_;
}
inline ::ddc::distributor::HeartBeatRequest* AnyRequest::mutable_heartbeatrequest() {
  set_has_heartbeatrequest();
  if (heartbeatrequest_ == NULL) heartbeatrequest_ = new ::ddc::distributor::HeartBeatRequest;
  return heartbeatrequest_;
}
inline ::ddc::distributor::HeartBeatRequest* AnyRequest::release_heartbeatrequest() {
  clear_has_heartbeatrequest();
  ::ddc::distributor::HeartBeatRequest* temp = heartbeatrequest_;
  heartbeatrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_heartbeatrequest(::ddc::distributor::HeartBeatRequest* heartbeatrequest) {
  delete heartbeatrequest_;
  heartbeatrequest_ = heartbeatrequest;
  if (heartbeatrequest) {
    set_has_heartbeatrequest();
  } else {
    clear_has_heartbeatrequest();
  }
}

// optional .ddc.distributor.HeartBeatResponse heartBeatResponse = 6;
inline bool AnyRequest::has_heartbeatresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnyRequest::set_has_heartbeatresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnyRequest::clear_has_heartbeatresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnyRequest::clear_heartbeatresponse() {
  if (heartbeatresponse_ != NULL) heartbeatresponse_->::ddc::distributor::HeartBeatResponse::Clear();
  clear_has_heartbeatresponse();
}
inline const ::ddc::distributor::HeartBeatResponse& AnyRequest::heartbeatresponse() const {
  return heartbeatresponse_ != NULL ? *heartbeatresponse_ : *default_instance_->heartbeatresponse_;
}
inline ::ddc::distributor::HeartBeatResponse* AnyRequest::mutable_heartbeatresponse() {
  set_has_heartbeatresponse();
  if (heartbeatresponse_ == NULL) heartbeatresponse_ = new ::ddc::distributor::HeartBeatResponse;
  return heartbeatresponse_;
}
inline ::ddc::distributor::HeartBeatResponse* AnyRequest::release_heartbeatresponse() {
  clear_has_heartbeatresponse();
  ::ddc::distributor::HeartBeatResponse* temp = heartbeatresponse_;
  heartbeatresponse_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_heartbeatresponse(::ddc::distributor::HeartBeatResponse* heartbeatresponse) {
  delete heartbeatresponse_;
  heartbeatresponse_ = heartbeatresponse;
  if (heartbeatresponse) {
    set_has_heartbeatresponse();
  } else {
    clear_has_heartbeatresponse();
  }
}

// optional .ddc.distributor.ShutdownRequest shutdownRequest = 7;
inline bool AnyRequest::has_shutdownrequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnyRequest::set_has_shutdownrequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnyRequest::clear_has_shutdownrequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnyRequest::clear_shutdownrequest() {
  if (shutdownrequest_ != NULL) shutdownrequest_->::ddc::distributor::ShutdownRequest::Clear();
  clear_has_shutdownrequest();
}
inline const ::ddc::distributor::ShutdownRequest& AnyRequest::shutdownrequest() const {
  return shutdownrequest_ != NULL ? *shutdownrequest_ : *default_instance_->shutdownrequest_;
}
inline ::ddc::distributor::ShutdownRequest* AnyRequest::mutable_shutdownrequest() {
  set_has_shutdownrequest();
  if (shutdownrequest_ == NULL) shutdownrequest_ = new ::ddc::distributor::ShutdownRequest;
  return shutdownrequest_;
}
inline ::ddc::distributor::ShutdownRequest* AnyRequest::release_shutdownrequest() {
  clear_has_shutdownrequest();
  ::ddc::distributor::ShutdownRequest* temp = shutdownrequest_;
  shutdownrequest_ = NULL;
  return temp;
}
inline void AnyRequest::set_allocated_shutdownrequest(::ddc::distributor::ShutdownRequest* shutdownrequest) {
  delete shutdownrequest_;
  shutdownrequest_ = shutdownrequest;
  if (shutdownrequest) {
    set_has_shutdownrequest();
  } else {
    clear_has_shutdownrequest();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace distributor
}  // namespace ddc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ddc::distributor::AnyRequest_Type>() {
  return ::ddc::distributor::AnyRequest_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_distributor_2eproto__INCLUDED
